<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HB 3D Web Viewer</title>
    <link rel="stylesheet" href="css/main.css">

    <httpProtocol>
        <customHeaders>
            <add name="Access-Control-Allow-Origin" value="*" />
        </customHeaders>
    </httpProtocol>

    <script> src = "./js/ViewerStartup.js"</script>

</head>

<body>

    <script type="module">

        import * as THREE from 'https://unpkg.com/three/build/three.module.js'

        import Stats from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/libs/stats.module.js'

        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js'

        const httpClient = new XMLHttpRequest();

        const getLatestDataUrl = 'https://localhost:44313/ApplicationData/GetLatest';

        let scene, container, camera, renderer, geometry, controls, material, stats;

        container = document.createElement('div');

        document.body.appendChild(container);

        startup();

        animation();

        function startup() {

            scene = new THREE.Scene();

            scene.background = new THREE.Color(0xcccccc);

            const grid = new THREE.GridHelper(100, 20, 0x000000, 0x000000);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);

            stats = new Stats();

            scene.add(stats);

            container.appendChild(stats.dom);

            initCamara();

            initRenderer();

            initControls();

            initLights();

            getMeshesFromHbApi();
        }

        function initCamara() {

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            camera.position.set(0, 20, 50)

            camera.lookAt(0, 0, 0);

            scene.add(camera)

        }


        function getMeshesFromHbApi() {

            httpClient.open("GET", getLatestDataUrl);
            httpClient.send();
        }


        httpClient.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {

                var json = httpClient.responseText;

                var applicationDataContainer = JSON.parse(json);

                var applicationData = applicationDataContainer.applicationData;

                for (let i = 0; i < applicationData.length; i++) {

                    let dataNode = applicationData[i];

                    let nodeStorageType = dataNode.entityType;

                    if (nodeStorageType != 'HB.RestAPI.Core.Types.HbMesh') continue;

                    let mesh = toThreeMesh(dataNode.rawData);

                    scene.add(mesh);

                }

            }
        }

        function toThreeMesh(hbJsonMesh) {


            const hbMesh = JSON.parse(hbJsonMesh);

            const faces = hbMesh.FaceIndexes.$values;

            const vertices = hbMesh.Vertices.$values;

            const geometry = new THREE.BufferGeometry();

            const bufferIndices = [];

            const bufferVertices = [];

            for (let i = 0; i < vertices.length; i++) {

                const vertexArray = vertices[i].$values;

                // TODO: Check if THREE JS handles quad meshes.
                // If incoming mesh quad - check.

                //if(vertexArray.length ==4) continue;

                for (let j = 0; j < vertexArray.length; j++) {

                    bufferVertices.push(vertexArray[j]);
                }

                //  bufferVertices.push(vertexArray[0],vertexArray[1],vertexArray[2]);

            }

            for (let i = 0; i < faces.length; i++) {

                const faceIndexArray = faces[i].$values;

                for (let j = 0; j < faceIndexArray.length; j++) {

                    bufferIndices.push(faceIndexArray[j]);
                }

            }

            geometry.setIndex(bufferIndices);

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(bufferVertices, 3));

            geometry.computeVertexNormals();

            material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true });

            let mesh = new THREE.Mesh(geometry, material);

            mesh.rotation.x = Math.PI / -2;

            return mesh;

        }

        function initRenderer() {

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0xffffff, 0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

        }

        function initControls() {

            controls = new OrbitControls(camera, renderer.domElement)
            controls.enablePan = true;
            controls.enableZoom = true;
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;

        }

        function initLights() {


            const dirLight1 = new THREE.DirectionalLight(0xffddcc, 1);
            dirLight1.position.set(1, 0.75, 0.5);
            scene.add(dirLight1);

            const dirLight2 = new THREE.DirectionalLight(0xccccff, 1);
            dirLight2.position.set(- 1, 0.75, - 0.5);
            scene.add(dirLight2);

            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

        }


        function animation() {

            requestAnimationFrame(animation);

            controls.update();

            stats.update();

            renderer.render(scene, camera);
        }

    </script>


</body>

</html>