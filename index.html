<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HB 3D Web Viewer</title>
    <link rel="stylesheet" href="css/main.css">

    <httpProtocol>
        <customHeaders>
            <add name="Access-Control-Allow-Origin" value="https://localhost:44313/" />
        </customHeaders>
    </httpProtocol>

    <script> src = "./js/ViewerStartup.js"</script>

</head>

<body>

    <script type="module">

        import * as THREE from 'https://unpkg.com/three/build/three.module.js'

        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js'

        // import { ViewerStartup } from './js/ViewerStartup.js';

        // let ccc = new ViewerStartup();

        // ccc.startUp();

        const Http = new XMLHttpRequest();

        let scene,mesh, camera, renderer, geometry, controls, material;

        const getLatestDataUrl = 'https://localhost:44313/ApplicationData/GetLatest';

        startup();
        animation();

        function startup() {

            scene = new THREE.Scene();

            scene.background = new THREE.Color(0xcccccc);

            const grid = new THREE.GridHelper(100, 20, 0x000000, 0x000000);
            grid.material.opacity = 0.2;
            grid.material.transparent = true;
            scene.add(grid);

            initCamara();

            initRenderer();

            initControls();

            initLights();

            addSceneGeometry();

            getGeometryFromBimorphApi();
        }

        function initCamara() {

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

            camera.position.set(0, 20, 50)

            camera.lookAt(0, 0, 0);

            scene.add(camera)

        }

        function addSceneGeometry() {

            //     const geoObject = new THREE.TorusKnotGeometry(10, 3, 100, 16);

            //  const material = new THREE.MeshPhongMaterial( {
            // 			color: 0xffffff,
            // 			flatShading: true,
            // 			shininess: 0
            // 		} );

            // 	const wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } );

            //     geometry = new THREE.Mesh(geoObject, material);

            //     let wireframe = new THREE.Mesh( geoObject, wireframeMaterial );

            //     geometry.add(wireframe);

            //     scene.add(geometry);
        }

        // Convrts a BimorphMesh as a Json string
        // to a Three.js mesh.
        function toThreeMesh(bimorphMeshJson) {

         

            let bimorphMesh = JSON.parse(bimorphMeshJson);

            
            var faces = bimorphMesh.FaceIndexes.$values;

            var vertices = bimorphMesh.Vertices.$values;

  

            const geometry = new THREE.BufferGeometry();
            const indices = [];
            const bufferGeoVertices = [];

    
        
            //debugger;
            for (var j = 0; j < vertices.length; j++) {

                var vertArray = vertices[j].$values;

                bufferGeoVertices.push(vertArray[0], vertArray[1], vertArray[2]);
            }

            for (let k = 0; k < faces.length; k++) {

                var faceArray = faces[k].$values;

                for (let m = 0; m < faceArray.length; m++) {

                    indices.push(faceArray[m])
                }

            }

           // debugger;
            geometry.setIndex(indices);
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(bufferGeoVertices, 3));
          // geometry.computeFaceNormals();

            material = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true });
            let mesh = new THREE.Mesh(geometry, material);
            mesh.rotation.x = Math.PI / -2;

            return mesh;

        }

        function getGeometryFromBimorphApi() {

            Http.open("GET", getLatestDataUrl);
            Http.send();

        }

        Http.onreadystatechange = function () {

            if (this.readyState == 4 && this.status == 200) {

             
                var json = Http.responseText;

                var nodeCollection = JSON.parse(json);

                var nodes = nodeCollection.applicationData;

                for (let i = 0; i < nodes.length; i++) {

                    let node = nodes[i];

                    let nodeStorageType = node.entityType;

                    if (nodeStorageType != 'HB.RestAPI.Core.Types.HbMesh') continue;

                    mesh = toThreeMesh(node.rawData)

                    scene.add(mesh);

                }

           


                // console.log(json)



            }
        }



        function animation() {

            requestAnimationFrame(animation);

            // geometry.rotation.x += 0.01;

            // geometry.rotation.y += 0.01

            renderer.render(scene, camera);


        }

        function initRenderer() {

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor(0xffffff, 0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

        }

        function initControls() {

            controls = new OrbitControls(camera, renderer.domElement)
            controls.enablePan = true;
            controls.enableZoom = true;
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;

        }

        function initLights() {


            const dirLight1 = new THREE.DirectionalLight(0xffddcc, 1);
            dirLight1.position.set(1, 0.75, 0.5);
            scene.add(dirLight1);

            const dirLight2 = new THREE.DirectionalLight(0xccccff, 1.1);
            dirLight2.position.set(- 1, 0.75, - 0.5);
            scene.add(dirLight2);

            const ambientLight = new THREE.AmbientLight(0x222222);
            scene.add(ambientLight);

        }



    </script>


</body>

</html>